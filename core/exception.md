# Исключения

## Иерархия исключений
<img src="https://github.com/sergeymi7/java-book/blob/main/core/hierarchy-exception.png" height="350" width="700">

Базовым классом для всех исключений является класс `Throwable`. От него уже наследуются два класса: `Error` и `Exception`.
Все остальные классы являются производными от этих двух классов.
Класс `Error` описывает внутренние ошибки в исполняющей среде Java.
Исключения наследуются от класса `Exception`. Среди этих исключений следует выделить класс `RuntimeException`. 
`RuntimeException` является базовым классом для так называемой группы непроверяемых исключений (*unchecked 
exceptions*) - компилятор не проверяет факт обработки таких исключений и их можно не указывать вместе с оператором 
`throws` в объявлении метода. Такие исключения являются следствием ошибок разработчика, например, неверное преобразование типов или выход за пределы массива.

Некоторые из классов непроверяемых исключений:
* `ArithmeticException`: исключение, возникающее при делении на ноль
* `IndexOutOfBoundException`: индекс вне границ массива
* `IllegalArgumentException`: использование неверного аргумента при вызове метода
* `NullPointerException`: использование пустой ссылки
* `NumberFormatException`: ошибка преобразования строки в число

Все остальные классы, образованные от класса `Exception`, называются проверяемыми исключениями (*checked exceptions*).
Некоторые из классов проверяемых исключений:
* `CloneNotSupportedException`: класс, для объекта которого вызывается клонирование, не реализует интерфейс `Cloneable`
* `InterruptedException`: поток прерван другим потоком
* `ClassNotFoundException`: невозможно найти класс

Подобные исключения обрабатываются с помощью конструкции `try..catch`. Либо можно передать обработку методу, который будет вызывать данный метод, указав исключения после оператора `throws`

Поскольку все классы исключений наследуются от класса `Exception`, то все они наследуют ряд его методов, которые 
позволяют получить информацию о характере исключения. Среди этих методов отметим наиболее важные:
* Метод `getMessage()` возвращает сообщение об исключении
* Метод `getStackTrace()` возвращает массив, содержащий трассировку стека исключения
* Метод `printStackTrace()` отображает трассировку стека
____
## try..catch

При возникновении исключения в блоке `try` управление переходит в блок `catch`, который может обработать данное 
исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а 
дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок 
`try..catch`. Например:
```java
public static void main(String[] args){
    try{
        int[]numbers=new int[3];
        numbers[4]=45;
        System.out.println(numbers[4]);
    }
        catch(Exception ex){
        ex.printStackTrace();
    }
        System.out.println("Программа завершена");
}
```
В данном случае, когда программа дойдет до строчки `numbers[4]=45;`, то обычный порядок выполнения остановится и 
перейдет в блок `catch`, и после вывода в консоль стека трассировки ошибки: `ex.printStackTrace();` программа 
продолжит свою работу, в нашем коде выполняя вывод текста: `System.out.println("Программа завершена");`

Конструкция `try..catch` также может иметь блок `finally`. Однако этот блок необязательный, и его можно при обработке 
исключений опускать. Блок `finally` выполняется в любом случае, возникло ли исключение в блоке `try` или нет.

#### Обработка нескольких исключений

В **Java** имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки `catch`:
```java
public static void main(String[] args){
    int[] numbers = new int[3];
    try{
        numbers[6]=45;
        numbers[6]=Integer.parseInt("abc");
    }
        catch(ArrayIndexOutOfBoundsException ex){
        System.out.println("Выход за пределы массива");
    }
        catch(NumberFormatException ex){
        System.out.println("Ошибка преобразования из строки в число");
    }
}
```
Если у нас возникает исключение определенного типа, то оно переходит к соответствующему блоку `catch`.
____
## Оператор throw

Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор `throw`. C 
помощью этого оператора мы можем создать исключение и вызвать его в процессе выполнения. 
В программе ниже происходит ввод числа, и мы хотим, чтобы, если число больше *30*, то возникало исключение:
```java
public class FirstApp {
    public static void main(String[] args) {
        try{
            Scanner in = new Scanner(System.in);
            int x = in.nextInt();
            if(x>=30){ 
                throw new Exception("Число х должно быть меньше 30");
            }
        }
        catch(Exception ex){
            System.out.println(ex.getMessage());
        }
        System.out.println("Программа завершена");
    }   
}
```
Здесь для создания объекта исключения используется конструктор класса `Exception`, в который передается сообщение об 
исключении. И если число **х** окажется больше **29**, то будет выброшено исключение и управление перейдет к блоку 
`catch`.
____
## try-with-resources

У классов, которые используют внешние ресурсы, есть специальный метод для их освобождения — `close()` так как они 
должны имплементировать интерфейс `AutoCloseable`.
После работы с файлом (или другим внешним ресурсом) вы должны вызвать у объекта, связанного с внешним ресурсом, 
метод `close()`.
Начиная с 7-й версии **Java**, в ней появился новый оператор `try-with-resources` (`try` с ресурсами).
Он создан как раз для того, чтобы решать проблему с обязательным вызовом метода `close()`. 
Имеет следующий вид:
```java
try (Класс имя = new Класс())
{
    Код, который работает с переменной имя
}
```
Это еще одна разновидность оператора `try`. После ключевого слова `try` нужно добавить круглые скобки, а внутри них 
— создать объекты с внешними ресурсами. Для объекта, указанного в круглых скобках, компилятор сам добавит секцию 
`finally` и вызов метода `close()`.
У оператора `try-with-resources` можно дописывать блоки `catch` и `finally`.

#### Несколько переменных одновременно

`try-with-resources` разрешает создавать в нем не один объект, а несколько. Код создания объектов должен разделяться 
точкой с запятой. Общий вид такой команды:
```java
String src = "c:\\projects\\log.txt";
String dest = "c:\\projects\\copy.txt";

try(FileInputStream input = new FileInputStream(src); FileOutputStream output = new FileOutputStream(dest)) {
   byte[] buffer = input.readAllBytes();
   output.write(buffer);
}
```
____
## Коды ответа HTTP
Код ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:
1.	Информационные 100 - 199
2.	Успешные 200 - 299
3.	Перенаправления 300 - 399
4.	Клиентские ошибки 400 - 499
5.	Серверные ошибки 500 - 599