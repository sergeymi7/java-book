# Типы памяти в JAVA

Память в **Java** состоит из трех компонентов: куча (**Heap space**), стек (**Stack space**) и метапространство (
**Metaspace**):

## Metaspace

В данном пространстве **Java** хранит неизменяемую информацию программы, например классы
* По умолчанию, **Metaspace** увеличивается автоматически. Однако и здесь у нас есть возможность управления памятью:
* При помощи `MetaspaceSize` и `MaxMetaspaceSize` можно задать границы **Metaspace** области.
* `MinMetaspaceFreeRatio` — минимальный зарезервированный размер памяти для метаданных классов после сборки мусора.
  Выражается в процентах от общего размера **Metaspace** области.
* `MaxMetaspaceFreeRatio` — максимальный зарезервированный размер памяти для метаданных классов после сборки мусора.
  Используется для предотвращения сокращения объема пространства, заполнение которого вызывает сборку мусора. Также
  выражается в процентах от общего размера **Metaspace**.
* В результате появления **Metaspace**, процесс очистки памяти получил некоторые преимущества. Теперь сборщик мусора
  автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает
  максимального значения. Вместе с этим, уменьшилась вероятность получения ошибки `OutOfMemoryError`.
* Несмотря на все плюсы, нам все равно необходимо контролировать и, при необходимости, настраивать **Metaspace**
  чтобы избежать утечек памяти.
  
____

## Heap space
В этой области хранится изменяемый контент
* Эта область памяти используется для объектов и классов. Новые объекты всегда создаются в куче, а ссылки на них
  хранятся в стеке.
* Эти объекты имеют глобальный доступ и могут быть получены из любого места программы.
* Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
    - **Young Generation** — область, где размещаются недавно созданные объекты. Когда она заполняется, происходит
      быстрая сборка мусора
    - **Old (Tenured) Generation** — здесь хранятся долгоживущие объекты. Когда объекты из **Young Generation**
      достигают определенного порога «возраста», они перемещаются в **Old Generation**
* Помимо рассмотренных ранее, куча имеет следующие ключевые особенности:
    - Когда эта область памяти полностью заполняется, **Java** бросает `java.lang.OutOfMemoryError`
    - Доступ к ней медленнее, чем к стеку
    - Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется
      сборщик мусора
    - В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя
      код
      
____

## Stack space

В стеке хранятся переменные, созданные в методах, и ссылки на переменные
* Стек работает по схеме **LIFO** (последним вошел, первым вышел). Всякий раз, когда вызывается новый метод,
  содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.
* Он заполняется и освобождается по мере вызова и завершения новых методов
* Переменные в стеке существуют до тех пор, пока выполняется метод, в котором они были созданы
* Если память стека будет заполнена, **Java** бросит исключение `java.lang.StackOverFlowError`
* Доступ к этой области памяти осуществляется быстрее, чем к куче
* Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек

<img src="https://github.com/sergeymi7/java-book/blob/main/core/image/memory-table.png" height="550" width="750">