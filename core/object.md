# Object

В Java определен один специальный класс, называемый Object. 
Все остальные классы являются подклассами, производными от этого класса, даже если в объявлении это явно не указано.
В классе Object определен ряд методов, которые доступны всем классам языка Java.

## Методы класса Object в Java:
1. protected Object clone() - создает новый объект, не отличающийся от клонируемого.
2. public boolean equals(Object obj) - определяет, равен ли один объект другому.
3. protected void finalize() - вызывается перед удалением неиспользуемого объекта.
4. public final Class<?> getClass() - получает класс объекта во время выполнения.
5. public int hashCode() - возвращает хеш-код, связанный с вызывающим объектом.
6. public final void notify() - возобновляет исполнение потока, ожидающего вызывающего объекта.
7. public final void notifyAll() - возобновляет исполнение всех потоков, ожидающих вызывающего объекта.
8. public String toString() - возвращает символьную строку, описывающую объект.
9. public final void wait() - ожидает другого потока исполнения.
10. public final void wait(long timeout) - ожидает другого потока исполнения.
11. public final void wait(long timeout, int nanos) - ожидает другого потока исполнения.


## Equals
В Java существует два вида сравнения:
- По ссылке
- По значению
Сравнение по ссылке происходит тогда, когда вы используете оператор ==.

### Переопределение
Требования из описания из `JavaDoc`:

* Рефлективность
    
    Для любой ссылки на значение `х` выражение `х.equals(x)` должно возвращать `true`.
    
* Симметричность 
  
  Для любых ссылок на значения `х` и `у` выражение `х.equals(y)` должно возвращать `tгue` тогда и только тогда, когда `y.equals(x)` возвращает `true`.
  
* Транзитивность
    Для любых ссылок на значения `х`, `у` и `z`, если `x.equals(y)` возвращает `true` и `y.equals(z)` возвращает `true`, то и выражение `х.equals(z)` должно возвращать `true`.

* Непротиворечивость или Согласованность
    
    Для любых ссылок на значения `х` и `у`, если несколько раз вызвать `х.equals(y)`, постоянно будет возвращаться значение `true`, либо постоянно будет возвращаться значение `false` при условии, что никакая информация, используемая при сравнении объектов, не поменялась.

* Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

* При переопределении `equals` необходимо переопределить и hashCode.

Итак, нам необходимо переопределить `equals`, напомним как выглядит сигнатура метода:

```java
@Override
public boolean equals(Object obj) {
    
}
```

В качестве аргумента метода передается `java.lang.Object`, это ссылочный тип, а значит может быть передан `null`.
Поэтому сначала необходимо проверить: а не является ли `obj` `null`-ом, чтобы обезопасить себя от `java.lang.NullPointerException`, если да, то возвращаем `false`.

После этого, хорошо бы сделать проверку, а не ссылается ли объект по ссылке `obj`, на наш текущий, на `this`?
Ведь если так, то объекты равны и никаких дальнейших сравнений делать не надо.

Теперь ответим на вопрос: а может ли объект по ссылке `obj` другого класса? Может, ведь ссылка у нас `Object`!
А значит, надо проверить: мы сравниваем объекты одного класса?

После этого ссылку `obj` можно безопасно скастовать к нашему классу и сделать сравнение полей.

Итого класс будет иметь вид:
```java
public class Person {
    private int age;
    private int number;
    private double salary;
    private String name;
    private CarKey carKey;

    public Person(int age, int number, String name, double salary, CarKey carKey) {
        this.age = age;
        this.number = number;
        this.name = name;
        this.salary = salary;
        this.carKey = carKey;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        if (number != person.number) return false;
        if (Double.compare(person.salary, salary) != 0) return false;
        if (name != null ? !name.equals(person.name) : person.name != null) return false;
        return carKey != null ? carKey.equals(person.carKey) : person.carKey == null;
    }
  }
```

## HashCode

Контракт `hashCode` предъявляет следующие требования к реализации:

* Если вызвать метод `hashCode` на одном и том же объекте, состояние которого не меняли, то будет возвращено **одно и то же** значение.
* Если два объекта равны, то вызов `hashCode` для каждого **обязан** давать один и тот же результат.
    > Равенство объектов проверяется через вызов метода [equals](./equals.md).
* Если два объекта имеют один и тот же `hash`-код, то это не гарантирует равенства объектов.

Проще говоря, разный `hash`-код у двух объектов - это гарантия того, что объекты не равны, в то время как одинаковый `hash`-код не гарантирует равенства.
