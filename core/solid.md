# SOLID

## S - Single Responsibility (SRP - принцип единственной ответственности)

Принцип декларирует, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью
инкапсулирована в класс, а все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.

Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей, на простые,
ответственность которых очень специализирована. Но также и объединении в отдельный класс однотипной функциональности,
которая может оказаться распределённой по многим классам, может рассматриваться как следование этому принципу.

## O - Open-Closed (OCP - принцип открытости-закрытости)

Принцип декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но
закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.

В этом контексте открытость для расширения — это возможность добавить для класса, модуля или функции новое поведение,
если необходимость в этом возникнет, а закрытость для изменений — это запрет на изменение исходного кода программных
сущностей.

Следование принципу **OCP** заключается в том, что программное обеспечение изменяется не через изменение существующего
кода, а через добавление нового кода. То есть созданный изначально код остаётся «нетронутым» и стабильным, а новая
функциональность внедряется либо через наследование реализации, либо через использование абстрактных интерфейсов и
полиморфизм.

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он
выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

## L — Liskov Substitution (LSP - принцип подстановки Барбары Лисков)

Следование принципу LSP заключается в том, что при построении иерархий наследования создаваемые наследники должны
корректно реализовывать поведение базового типа. То есть если базовый тип реализует определённое поведение, то это
поведение должно быть корректно реализовано и для всех его наследников.

LSP перекликается с контрактным программированием, определяя точные, формальные и верифицируемые описания интерфейсов. И
интерфейсы, реализуeмые наследниками, должны соответствовать контракту интерфейсов базового класса.

Наследник класса дополняет, но не заменяет поведение базового класса. То есть в любом месте программы замена базового
класса на класс-наследник не должна вызывать проблем.

Соблюдение принципа подстановки Барбары Лисков позволяет гарантировать, что любой созданный нами подкласс будет без
проблем использоваться ранее реализованными модулями, которые работали с надклассом.

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым
образом без нарушения работы программы.

## I — Interface Segregation (ISP - принцип разделения интерфейсов)

Принцип в формулировке Роберта Мартина декларирует, что клиенты не должны зависеть от методов, которые они не
используют. То есть если какой-то метод интерфейса не используется клиентом, то изменения этого метода не должны
приводить к необходимости внесения изменений в клиентский код.

Следование принципу ISP заключается в создании интерфейсов, которые достаточно специфичны и требуют только необходимый
минимум реализаций методов.

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс
делает то, что от него действительно требуется, и ничего больше.

## D — Dependency Inversion (Принцип инверсии зависимостей)

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Например, мы реализуем хранение документов в веб-приложении. На первый взгляд, кажется логичным добавить зависимость от
модулей работы с файловой системой непосредственно в класс, отвечающий за высокоуровневую работу с этими документами. Но
в перспективе такая зависимость может создать проблемы — например, нам потребуется хранить данные не только на диске, но
и в облаке. Если зависимость внедрена от реализации, то мы столкнёмся с необходимостью её переработки. Если же
зависимость выведена на уровень абстракции (интерфейса), то нам будет достаточно реализовать функционал работы с
облаком, соответствующий ранее созданному интерфейсу работы с файлами.

Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт
введения интерфейсов.

### Пример:

```java
public class WeatherTracker {

    String currentConditions;
    Phone phone;
    Emailer emailer;

    public WeatherTracker() {
        phone = new Phone();
        emailer = new Emailer();
    }

    public void setCurrentConditions(String weatherDescription) {
        this.currentConditions = weatherDescription;
        if (weatherDescription == "rainy") {
            String alert = phone.generateWeatherAlert(weatherDescription);
            System.out.print(alert);
        }
        if (weatherDescription == "sunny") {
            String alert = emailer.generateWeatherAlert(weatherDescription);
            System.out.print(alert);
        }
    }
}
```

В зависимости от описания погоды выбирается тип оповещения.

Так вот текущая релизация завязана на реализации **phone** и **emailer**, что не дает нам гибкости в использовании.

Чтобы исправить текущий недостаток, необходимо выделить уровень абстракции, от которой будут зависеть реализации.

В таком случае код будет выглядеть следующим образом:

```java
interface Notifier {

    public void alertWeatherConditions(String weatherConditions);
}

public class MobileDevice implements Notifier {

    public void alertWeatherConditions(String weatherConditions) {
        if (weatherConditions == "rainy")
            System.out.print("It is rainy");
    }
}

public class EmailClient implements Notifier {

    public void alertWeatherConditions(String weatherConditions) {
        if (weatherConditions == "sunny")
            ;
        System.out.print("It is sunny");
    }
}

public class WeatherTracker {

    String currentConditions;

    public void setCurrentConditions(String weatherDescription) {
        this.currentConditions = weatherDescription;
    }

    public void notify(Notifier notifier) {
        notifier.alertWeatherConditions(currentConditions);
    }
}
```
В текущей реализации как раз детали зависят от абстракции и модуль верхнего уровня не зависит от модулей нижнего уровня(
реализации Notifier).