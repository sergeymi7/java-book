# Интеграция

1. Основные уровни модели OSI
2. Основы протокола: WebSocket, SSE, long polling, polling
3. Подробности протокола HTTP: caching, keep-alive content-type,cookie, CORS
4. Принцип построения RESful API
5. Паттерны отказоустойчивости: circuit breaker, retry, fallback,rate limiter

## Основные уровни модели OSI

Модель **OSI** (Open Systems Interconnection) - это стандарт, определяющий сетевую архитектуру и ее функциональность. Он
описывает, как различные устройства в сети должны взаимодействовать между собой, чтобы обеспечить связность и передачу
данных.

Модель **OSI** состоит из семи уровней, которые описывают различные функции и процессы, необходимые для обмена данными в
сети:

1. Физический уровень (Physical Layer) - этот уровень определяет физические характеристики среды передачи данных, такие
   как кабели, разъемы, сигналы и физические интерфейсы. На этом уровне данные представлены в виде битов.
2. Канальный уровень (Data Link Layer) - этот уровень обеспечивает надежную передачу данных между устройствами в
   пределах одной сети. На этом уровне данные представлены в виде кадров.
3. Сетевой уровень (Network Layer) - этот уровень управляет передачей данных между различными сетями и обеспечивает
   маршрутизацию данных. На этом уровне данные представлены в виде пакетов.
4. Транспортный уровень (Transport Layer) - этот уровень обеспечивает надежную передачу данных между конечными
   устройствами, контролирует поток данных и управляет соединениями. На этом уровне данные представлены в виде
   сегментов.
5. Сеансовый уровень (Session Layer) - этот уровень управляет установлением, поддержанием и завершением сеансов между
   устройствами. На этом уровне данные представлены в виде сообщений.
6. Уровень представления (Presentation Layer) - этот уровень отвечает за преобразование данных в формат, понятный
   устройству назначения, и обеспечивает безопасность и защиту данных. На этом уровне данные представлены в виде
   синтаксических структур.
7. Прикладной уровень (Application Layer) - этот уровень обеспечивает доступ к приложениям и службам, используемым в
   сети. На этом уровне данные представлены в виде сообщений и запросов.

Каждый уровень модели **OSI** выполняет свою функцию и использует протоколы и средства для обеспечения надежности и
эффективности передачи данных.

## Основы протокола: WebSocket, SSE, long polling, polling

**WebSocket**, **SSE**, **long polling** и **polling** - это различные методы взаимодействия между клиентом и сервером
через протокол **HTTP**.

1. **WebSocket** - это протокол, который позволяет установить двунаправленное соединение между клиентом и сервером и
   передавать данные в режиме реального времени. **WebSocket** использует одно TCP-соединение, что позволяет избежать
   накладных расходов на каждое обращение к серверу. **WebSocket** особенно полезен для приложений, которые требуют
   мгновенной передачи данных, например, онлайн-игры, приложения мгновенных сообщений и т.д.

2. **SSE** (Server-Sent Events) - это технология, позволяющая серверу отправлять данные клиенту без необходимости
   обновлять страницу или делать запросы от клиента. **SSE** позволяет установить однонаправленное соединение между
   клиентом и сервером, где сервер отправляет сообщения клиенту в формате текста или **JSON**. **SSE** особенно полезен
   для реализации функциональности таких приложений, как новостные ленты, лайв-события и т.д.

3. **Long Polling** - это технология, которая позволяет клиенту отправлять запрос на сервер и ожидать ответа в течение
   определенного времени, даже если сервер не имеет новых данных для передачи. Если сервер получает новые данные, он
   отправляет ответ клиенту, и клиент затем отправляет новый запрос. **Long Polling** может использоваться в
   приложениях, которые нуждаются в регулярном обновлении данных, например, мгновенных сообщениях, социальных сетях и
   т.д.

4. **Polling** - это метод опроса сервера, который заключается в том, что клиент отправляет периодические запросы на
   сервер для получения обновленных данных. Этот метод имеет недостаток в том, что он создает большую нагрузку на сервер
   и тратит много ресурсов на каждый запрос. **Polling** используется реже, чем другие методы, но может быть полезен в
   случаях, когда клиент не ожидает регулярного обновления данных и не нуждается в мгновенной передаче данных.

## Подробности протокола HTTP: caching, keep-alive content-type,cookie, CORS

Протокол **HTTP** (HyperText Transfer Protocol) - это протокол передачи данных, используемый для передачи данных в
Интернете.

Вот некоторые подробности о некоторых его функциях:

1. **Caching** - HTTP позволяет браузерам и прокси-серверам сохранять ресурсы, полученные из Интернета, в локальном кеше
   для быстрого доступа к этим ресурсам в будущем. Кеш можно настроить таким образом, чтобы сохранять копии ресурсов в
   течение определенного времени или до тех пор, пока ресурсы не будут обновлены на сервере.

2. **Keep-Alive** - это механизм, который позволяет браузерам и серверам сохранять открытое соединение для более
   эффективного обмена данными, вместо того, чтобы устанавливать новое соединение каждый раз, когда необходимо обменять
   данными. Это сокращает нагрузку на сервер и уменьшает задержку при загрузке страницы.

3. **Content-Type** - это заголовок, который указывает тип содержимого, передаваемого по протоколу HTTP, например,
   текст, изображения, видео или аудио. Этот заголовок используется для правильного отображения содержимого на стороне
   клиента.

4. **Cookie** - это небольшой фрагмент данных, отправляемый сервером на клиент, который затем хранится на клиентском
   компьютере. Cookie используются для сохранения данных, связанных с пользователем, таких как логин, предпочтения и
   т.д. и позволяют серверу запоминать состояние клиента между запросами.

5. **CORS** (Cross-Origin Resource Sharing) - это механизм, который позволяет браузерам выполнять запросы на ресурсы,
   находящиеся на других доменах. По умолчанию браузеры блокируют запросы на ресурсы, находящиеся на других доменах, из
   соображений безопасности. CORS позволяет серверу указать, какие домены могут выполнять запросы на его ресурсы.

## Принцип построения RESful API

**REST** (Representational State Transfer) - это стиль архитектуры для построения распределенных приложений, основанный
на протоколе HTTP. RESTful API - это способ построения API (Application Programming Interface) в соответствии с
принципами REST.

Основные принципы построения **RESTful API** включают:

1. Использование **HTTP** методов - **RESTful API** должно использовать стандартные методы **HTTP**, такие как **GET**,
   **POST**, **PUT**, **PATCH** и **DELETE**, для доступа к ресурсам.

2. Использование **URI** (Uniform Resource Identifier) - каждый ресурс должен быть доступен по уникальному **URI**.
   **URI** должен быть понятным и описывать ресурс, на который он указывает.

3. Использование **JSON** или **XML** форматов для передачи данных - **RESTful API** должно использовать форматы данных,
   такие как **JSON** или **XML**, для передачи данных между клиентом и сервером.

4. Использование **HTTP** заголовков - **RESTful API** должно использовать **HTTP** заголовки, такие как
   **Content-Type**, для указания типа данных, которые передаются в запросе или ответе.

5. Отсутствие состояния - **RESTful API** должно быть без состояния, что означает, что каждый запрос должен содержать
   всю необходимую информацию для выполнения запроса. Сервер не должен сохранять состояние между запросами.

6. Использование гиперссылок (?) - **RESTful API** должно использовать гиперссылки для указания доступных действий с
   ресурсами. Например, при получении ресурса, **API** должно включать ссылки на другие ресурсы, которые могут быть
   полезны клиенту.

7. Поддержка кеширования - **RESTful API** должно поддерживать кеширование, что означает, что клиенты могут сохранять
   ответы на запросы в кеше для более быстрого доступа к ресурсам.

8. Поддержка безопасности - **RESTful API** должно поддерживать механизмы безопасности, такие как аутентификация и
   авторизация, для защиты ресурсов от несанкционированного доступа.

## Паттерны отказоустойчивости: circuit breaker, retry, fallback,rate limiter

Паттерны отказоустойчивости используются для обеспечения надежности и устойчивости системы к сбоям. Ниже перечислены
некоторые из популярных паттернов отказоустойчивости:

1. **Circuit Breaker** - Этот паттерн отключает сервис, который временно не может обработать запросы, и использует
   запасной вариант обработки запросов. Если сервис восстановится, он снова включится, если нет — то будет
   использоваться запасной сервис. Это помогает избежать повторных неудачных запросов к сервису и ускоряет
   восстановление после сбоя.

2. **Retry** - Этот паттерн предполагает повторную отправку запроса в случае, если первоначальный запрос был неудачным.
   Это может происходить, когда произошел временный сбой в сети, или когда сервис временно не доступен. При этом можно
   использовать различные стратегии повтора, например, экспоненциальное увеличение интервала между повторами.

3. **Fallback** - Этот паттерн используется, когда основной сервис не может обработать запрос, и вместо него
   используется запасной сервис. Это позволяет поддерживать некоторую функциональность даже при поломке основного
   сервиса.

4. **Rate Limiter** - Этот паттерн используется для управления скоростью обработки запросов в системе. Он позволяет
   ограничивать число запросов, поступающих на сервер, что помогает избежать перегрузки и снижает вероятность отказа.

Ключевая разница между паттернами **Fallback** и **Circuit Breaker** заключается в их целях. **Fallback** предназначен
для обеспечения альтернативного механизма обработки запросов в случае, если основной механизм не работает. 
**Circuit Breaker**, с другой стороны, предназначен для временного отключения сервиса, который не может обработать запросы, и
переключения на запасной сервис.

Все эти паттерны могут быть применены в различных сценариях и помогают обеспечить отказоустойчивость системы в целом.