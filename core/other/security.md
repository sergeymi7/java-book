# Security

1. Основы симметричного\ассиметричного шифрования.
2. Основы SSL
3. Аутентификация, авторизация, идентификация
4. Способы не допускать SQL/XSS/XXE инъекции в коде своих приложений
5. Способы защититься от MITM

## Основы симметричного\ассиметричного шифрования.

Симметричное и асимметричное шифрование — это два основных типа криптографических алгоритмов, которые используются для
защиты данных в информационной безопасности.

Симметричное шифрование использует **один и тот же ключ** как для шифрования, так и для расшифровки данных. Это
означает, что отправитель и получатель общаются, используя один и тот же ключ. Например, если Антоха отправляет
сообщение Сереге, он шифрует его с помощью ключа, который известен только ему и Сереге, а Серега расшифровывает
сообщение, используя этот же ключ. Один из самых распространенных алгоритмов симметричного шифрования — **AES** (
Advanced Encryption Standard).

Асимметричное шифрование, также известное как открытый ключ, **использует два разных ключа** — публичный и приватный.
Публичный ключ может быть опубликован и использован любым отправителем для шифрования сообщения, а только владелец
приватного ключа может расшифровать сообщение, используя его. Например, если Антоха хочет отправить сообщение Сереге, он
использует публичный ключ Сереги для шифрования сообщения, а Серега использует свой приватный ключ для расшифровки. Один
из самых распространенных алгоритмов асимметричного шифрования - **RSA** (Rivest–Shamir–Adleman).

В целом, асимметричное шифрование более безопасно, чем симметричное, потому что не требует передачи одного и того же
ключа между отправителем и получателем, что делает его менее уязвимым для атак посередине. Однако, асимметричное
шифрование требует более сложных вычислений и потребляет больше ресурсов, чем симметричное, поэтому в некоторых случаях
может быть неэффективным. Обычно используется комбинация обоих методов для обеспечения безопасности данных в
информационной безопасности.

## Основы SSL

**SSL** (Secure Sockets Layer) - это протокол шифрования, который используется для защиты данных, передаваемых по
интернету. **SSL** был разработан компанией **Netscape Communications** в 1994 году и был первоначально предназначен для
защиты онлайн-транзакций в электронной коммерции. В настоящее время **SSL** устарел и заменен на протокол **TLS** (
Transport Layer Security), но термин **SSL** все еще широко используется в связи с защитой соединений.

Основная цель **SSL** - обеспечить безопасность передачи данных, предотвращая возможность их перехвата или подмены
третьими сторонами. **SSL** работает на уровне транспортного протокола, который обеспечивает надежную передачу данных
между клиентом и сервером.

Когда пользователь пытается установить защищенное соединение с сервером, **SSL** использует следующие основные процессы:

1. Протокол рукопожатия **SSL**: клиент и сервер устанавливают соединение, во время которого они обмениваются
   информацией о криптографических ключах, используемых для шифрования данных.

2. Шифрование данных: после установления соединения клиент и сервер могут обмениваться зашифрованными данными, что
   защищает их от прослушивания.

3. Проверка подлинности сервера: **SSL** может использовать сертификаты, чтобы проверить, что сервер является
   действительным сервером, а не поддельным сервером, который может попытаться перехватить данные.

**SSL** использует асимметричное шифрование для установки защищенного соединения между клиентом и сервером. Когда клиент
отправляет запрос на сервер, сервер отправляет обратно свой сертификат **SSL**, который содержит публичный ключ. Клиент
использует публичный ключ для шифрования сеансового ключа, который используется для шифрования дальнейшей коммуникации
между клиентом и сервером. После этого клиент и сервер могут обмениваться данными, которые защищены с помощью сеансового
ключа.

**SSL** также может использовать симметричное шифрование для шифрования данных. В этом случае сеансовый ключ
используется для шифрования и расшифрования данных, которые передаются между клиентом и сервером.

В целом, **SSL** обеспечивает безопасность передачи данных через интернет, защищая их от несанкционированного
воздействия из вне.

## Аутентификация, авторизация, идентификация

Аутентификация, авторизация и идентификация — это три взаимосвязанных концепции, которые используются для обеспечения
безопасности в различных областях, включая информационную безопасность, системы управления доступом и т.д.

**Идентификация** - это процесс определения личности пользователя или сущности. Для идентификации пользователей часто
используются имена пользователя и пароли, уникальные идентификаторы, биометрические данные и другие факторы.
Идентификация позволяет системе установить личность пользователя и отличить его от других пользователей.

**Аутентификация** - это процесс проверки подлинности идентификационных данных пользователя. Для этого обычно
используются пароли, ключи, биометрические данные и другие факторы. Аутентификация проверяет, что пользователь является
владельцем учетной записи и что идентификационные данные, предоставленные пользователем, являются верными.

**Авторизация** - это процесс определения прав доступа пользователя к определенным ресурсам или функциям в системе на
основе его аутентификации и идентификации. Авторизация гарантирует, что только авторизованные пользователи имеют доступ
к определенным ресурсам или функциям, а неавторизованные пользователи не имеют.

Например, при доступе к веб-сайту, пользователь должен предоставить идентификационные данные (логин и пароль) для
идентификации. После успешной идентификации система проверяет эти данные на подлинность (аутентификация) и, если данные
верны, определяет, какие права доступа имеет пользователь (авторизация). Если пользователь имеет соответствующие права
доступа, то система разрешает ему доступ к определенным ресурсам. Если нет, то доступ запрещен.

## Способы не допускать SQL/XSS/XXE инъекции в коде своих приложений

SQL-инъекции, XSS-инъекции и XXE-инъекции - это типичные атаки, которые используются для взлома приложений. Ниже
приведены некоторые способы предотвращения этих атак.

1. SQL-инъекции - это атака, которая позволяет злоумышленнику внедрять SQL-запросы в приложение и получать доступ к базе
   данных. Для защиты от SQL-инъекций необходимо использовать подготовленные выражения, параметризованные запросы и
   фильтрацию входных данных.

2. XSS-инъекции - это атака, которая позволяет злоумышленнику внедрять скрипты в веб-страницы приложения и выполнять их
   на компьютерах пользователей, просматривающих эти страницы. Для защиты от XSS-инъекций необходимо правильно
   экранировать пользовательский ввод и выводить его на странице в безопасном формате, таком как HTML-entities.

3. XXE-инъекции - это атака, которая позволяет злоумышленнику внедрять вредоносный код в XML-документы, обрабатывающихся
   приложением, и запускать его на сервере. Для защиты от XXE-инъекций необходимо использовать XML-парсеры с защитой от
   внедрения вредоносного кода и отключить функциональность, которая позволяет загружать внешние сущности в
   XML-документы.

Общие методы для защиты от инъекций включают:

* Валидация пользовательского ввода
* Экранирование (escaping) специальных символов
* Использование подготовленных запросов
* Ограничение доступа к базе данных
* Минимизация привилегий доступа для приложения и его компонентов

1. Параметризация запросов **SQL**: Параметризация запросов **SQL** позволяет отделить данные от кода SQL, предотвращая
   возможность инъекций. Чтобы не вставлять значения напрямую в **SQL**-запрос, необходимо использовать параметры. Это
   поможет защитить от **SQL**-инъекций.

2. Использование подготовленных выражений: Использование подготовленных выражений помогает предотвратить SQL-инъекции.
   Подготовленные выражения предоставляют способ разделения данных и кода **SQL**.

3. Валидация пользовательского ввода: Валидация пользовательского ввода является важным способом предотвращения
   **XSS**-инъекций. Все входные данные должны быть проверены на предмет возможных уязвимостей.

4. Экранирование специальных символов: Экранирование специальных символов помогает предотвратить XSS-инъекции. Все
   специальные символы должны быть экранированы, чтобы они не могли быть интерпретированы как код.

5. Использование контролей ввода: Использование контролей ввода помогает предотвратить XSS-инъекции. Контроли ввода
   ограничивают пользовательский ввод только допустимыми символами.

6. Ограничение доступа к файловой системе: Ограничение доступа к файловой системе помогает предотвратить XXE-инъекции.
   Необходимо проверять загруженные файлы и не давать им доступ к файловой системе без необходимости.

Использование библиотек и фреймворков с обеспеченной безопасностью: Использование библиотек и фреймворков с обеспеченной
безопасностью может помочь предотвратить многие виды атак. Большинство фреймворков предоставляют встроенные функции
безопасности, которые облегчают задачу предотвращения атак.

## Способы защититься от MITM

**MITM** (Man-in-the-middle) атака - это атака на сетевое соединение, при которой злоумышленник получает доступ к
передаваемым данным между двумя узлами, к которым он не имеет прямого доступа.

Способы защиты от **MITM** атак:

1. Использование протоколов шифрования - SSL/TLS - для защиты передаваемых данных. Протокол SSL/TLS использует
   шифрование данных, что позволяет обеспечить конфиденциальность и целостность передаваемых данных.
2. Проверка сертификатов SSL/TLS - это гарантирует, что соединение установлено с правильным сервером и что сервер имеет
   правильный SSL-сертификат.
3. Использование сильных паролей и механизмов аутентификации. Это помогает защитить доступ к устройствам и системам от
   несанкционированного доступа.
4. Использование VPN-соединений. VPN (Virtual Private Network) позволяет создавать защищенные каналы связи между
   удаленными компьютерами через общедоступные сети, такие как интернет.
5. Использование двухфакторной аутентификации. Это дополнительный уровень защиты, который требует от пользователя ввода
   кода подтверждения после ввода пароля.
6. Проверка на наличие **MITM** атак с помощью инструментов, таких как Wireshark или SSLStrip.
7. Не подключаться к общедоступным Wi-Fi сетям без необходимости, так как они могут быть скомпрометированы.

Важно понимать, что защита от **MITM** атак требует комплексного подхода, и использование любого одного из вышеуказанных
методов может быть недостаточным.

### Пример MITM атаки:

Создать сервер, который будет слушать входящие соединения на определенном порту и получать запросы клиентов.

```java
public class Server {

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8080);
        Socket clientSocket = serverSocket.accept();
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        String inputLine;
        while ((inputLine = in.readLine()) != null) {
            System.out.println("Received message: " + inputLine);
        }
        in.close();
        clientSocket.close();
        serverSocket.close();
    }
}
```

Создать клиент, который будет отправлять запрос на сервер.

```java
public class Client {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("localhost", 8080);
        PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
        out.println("Hello, server!");
        socket.close();
    }
}
```

Создать класс, который будет перехватывать данные, отправляемые клиентом, и изменять их, прежде чем они будут доставлены
на сервер.

```java
public class MITMAttack {

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9090);
        Socket clientSocket = serverSocket.accept();
        BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        String inputLine;
        while ((inputLine = in.readLine()) != null) {
            System.out.println("Received message: " + inputLine);
            // Изменяем сообщение перед отправкой на сервер
            inputLine = inputLine.replace("Hello, server!", "Hello, hacker!");
            // Отправляем сообщение на сервер
            Socket serverSocket = new Socket("localhost", 8080);
            PrintWriter out = new PrintWriter(serverSocket.getOutputStream(), true);
            out.println(inputLine);
            serverSocket.close();
        }
        in.close();
        clientSocket.close();
        serverSocket.close();
    }
}
```

Запустить сервер, клиент и MITMAttack. Клиент отправит запрос на сервер, который будет перехвачен и изменен MITMAttack,
а затем отправлен на сервер. Сервер получит измененный запрос и обработает его, не зная о том, что данные были изменены.