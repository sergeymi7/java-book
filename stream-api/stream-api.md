# Stream API

**Stream API** был введен в **Java 8** и представляет собой совершенно новый подход к работе с данными в **Java**. В
основе Stream API
лежат [концепции функционального программирования](https://github.com/sergeymi7/java-book/blob/main/core/other/functional-programming.md)
и [лямбда-выражений]((https://github.com/sergeymi7/java-book/blob/main/core/other/lambda.md)).

## Основные концепции

- **Stream**: Stream представляет собой последовательность элементов и предоставляет различные методы для обработки этих
  элементов. Stream можно создать из различных источников данных, таких как коллекции, списки, наборы, массивы и т.д.
- **Операции над Stream**: Операции над Stream'ами делятся на промежуточные (intermediate) и терминальные (terminal)
  операции.
    - **Промежуточные операции** возвращают новый Stream, так что вы можете комбинировать несколько промежуточных
      операций, создавая так называемую "цепочку" операций. Примеры промежуточных операций: `filter`, `map`, `sorted`.
    - **Терминальные операции** возвращают результат определенного типа и завершают цепочку операций над Stream. Примеры
      терминальных операций: `collect`, `forEach`, `reduce`.
- **Параллельные Streams**: **Java 8** представила концепцию параллельных Streams, которые могут значительно ускорить
  выполнение операций за счет использования нескольких ядер процессора.

## Примеры использования Stream API

Возьмем простой пример использования Stream API. Допустим, у вас есть список имен, и вы хотите найти все имена, которые
начинаются на букву "А", и отсортировать их:

```java
List<String> names=Arrays.asList("Serega","Anton");
    List<String> result=names.stream() // создаем Stream
    .filter(name->name.startsWith("A")) // промежуточная операция
    .sorted() // промежуточная операция
    .collect(Collectors.toList()); // терминальная операция

    System.out.println(result); // [Anton]
```

В этом примере используются следующие операции Stream API:

- `stream()`: Создает Stream из списка имен.
- `filter()`: Отбирает элементы Stream, которые удовлетворяют заданному условию.
- `sorted()`: Сортирует элементы Stream в естественном порядке.
- `collect()`: Собирает элементы Stream в другую структуру данных, в данном случае – в список.

## Промежуточные операции

Промежуточные операции (intermediate operations) в **Stream API Java** обладают несколькими важными особенностями:

- **Они возвращают новый Stream**: Промежуточные операции не меняют исходный Stream, вместо этого они создают новый
  Stream с результатами.
- **Они ленивые**: Промежуточные операции не выполняются немедленно при вызове. Они выполняются только тогда, когда
  вызывается терминальная операция, и то только на элементах, которые необходимы для выполнения терминальной операции.
- **Они могут быть объединены в цепочки**: Поскольку промежуточные операции возвращают Stream, они могут быть объединены
  в цепочки (чейнинг).

Промежуточные операции:

- `filter(Predicate<T> predicate)`: Принимает `Predicate` (условие, которое является истинным или ложным) и возвращает
  Stream, содержащий только те элементы исходного Stream, удовлетворяющие условию.
- `map(Function<T,R> mapper)`: Принимает `Function` (функцию, которая принимает одно значение и возвращает другое),
  применяет ее к каждому элементу и возвращает Stream, содержащий результаты.
- `flatMap(Function<T,Stream<R>> mapper)`: Используется для преобразования каждого элемента в Stream и затем "
  сплющивает" все эти Streams в один Stream.
- `distinct()`: Возвращает Stream, в котором удалены дубликаты. Это достигается с помощью метода `equals()` объектов.
- `sorted()`: Возвращает Stream, отсортированный в натуральном порядке. Также может принимать компаратор в качестве
  аргумента.
- `peek(Consumer<T> action)`: Возвращает Stream, содержащий элементы исходного Stream, но перед возвратом каждый элемент
  обрабатывается заданным `Consumer`. Полезно для отладки.
- `limit(long maxSize)`: Ограничивает Stream заданным числом элементов.
- `skip(long n)`: Пропускает первые n элементов Stream.
- `takeWhile(Predicate<T> predicate)`: (добавлен в Java 9) Возвращает Stream, содержащий элементы до тех пор, пока они
  удовлетворяют предикату.
- `dropWhile(Predicate<T> predicate)`: (добавлен в Java 9) Пропускает элементы Stream до тех пор, пока они удовлетворяют
  предикату, затем возвращает Stream, содержащий оставшиеся элементы.
- `concat(Stream<T> a, Stream<T> b)`: Объединяет два Stream в один.

Примечание: Все эти операции, кроме concat, являются методами экземпляра и вызываются на объекте Stream, в то время как
concat является статическим методом и вызывается на классе Stream.

Пример использования промежуточных операций:

```java
List<String> names=Arrays.asList("Serega",,"Anton");
    List<String> result=names.stream() // создаем Stream
    .filter(name->name.startsWith("A")) // промежуточная операция
    .sorted() // промежуточная операция
    .collect(Collectors.toList()); // терминальная операция
```

В этом примере `filter()` и `sorted()` являются промежуточными операциями. Они не выполняются, пока не вызвана
терминальная операция collect().

Промежуточные операции в Stream API работают вместе как цепочка. Каждая операция берет Stream в качестве входных данных,
выполняет некоторую обработку и возвращает новый Stream в качестве выходных данных. Это позволяет выстраивать цепочки
промежуточных операций.

Однако важно понимать, что эти цепочки операций являются "ленивыми". Это означает, что промежуточные операции не
выполняются немедленно при их вызове. Вместо этого они "запланированы" для выполнения и активизируются только тогда,
когда вызывается терминальная операция. Кроме того, промежуточные операции выполняются в одном проходе, а не в
нескольких последовательных проходах.

Рассмотрим следующий пример:

```java
List<Integer> numbers=Arrays.asList(1,2,3,4,5,6,7,8,9,10);
    List<Integer> result=numbers.stream() // создаем Stream
    .filter(n->{
    System.out.println("Фильтрация "+n);
    return n%2==0;
    }) // промежуточная операция
    .map(n->{
    System.out.println("Преобразование "+n);
    return n*n;
    }) // промежуточная операция
    .limit(3) // промежуточная операция
    .collect(Collectors.toList()); // терминальная операция
```

В этом примере у нас есть две промежуточные операции: `filter` и `map`, и одна терминальная операция: `collect`.

Когда мы запускаем этот код, мы увидим, что операции `filter` и map выполняются не по отдельности для всех элементов, а
совместно для каждого элемента по очереди. Это происходит потому, что эти операции "ленивы" и Stream API пытается
обрабатывать данные наиболее эффективным способом, минимизируя количество проходов.

Также, благодаря "ленивости" операций и наличию операции `limit`, обработка прекращается после первых трех элементов,
удовлетворяющих условию. Это демонстрирует эффективность Stream API при работе с большими объемами данных.

## Терминальные операции

Терминальные операции в Stream API в Java запускают обработку данных и возвращают результат, который уже не является
Stream. Они отличаются от промежуточных операций, которые просто трансформируют Stream и возвращают другой Stream.

Важные особенности терминальных операций:

- **Они запускают обработку**: Терминальные операции инициируют обработку данных в Stream. Без терминальной операции
  промежуточные операции не будут выполнены, поскольку они "ленивые" и ожидают терминальной операции для активации.
- **Они закрывают Stream**: После выполнения терминальной операции Stream становится недоступным для дальнейшего
  использования. Попытка использовать Stream после того, как на нем была вызвана терминальная операция, приведет к
  исключению `IllegalStateException`.

Вот некоторые примеры терминальных операций:

- `forEach(Consumer<T> action)`: Применяет заданное действие к каждому элементу Stream. Ничего не возвращает.
- `toArray()`: Преобразует Stream в массив.
- `reduce(BinaryOperator<T> accumulator)`: Применяет функцию сокращения ко всем элементам Stream, в результате
  возвращается Optional.
- `collect(Collector<T,A,R> collector)`: Преобразует Stream в другую форму. Обычно используется для преобразования
  Stream в коллекции.
- `min(Comparator<T> comparator) и max(Comparator<T> comparator)`: Возвращают минимальный и максимальный элемент Stream
  соответственно, в соответствии с заданным компаратором.
- `count()`: Возвращает количество элементов в Stream.
- `anyMatch(Predicate<T> predicate), allMatch(Predicate<T> predicate) и noneMatch(Predicate<T> predicate)`: Возвращают
  булево значение, показывающее, удовлетворяют ли элементы Stream заданному условию.
- `findFirst()` и `findAny()`: Возвращают первый или любой элемент из Stream соответственно. Это особенно полезно в
  параллельных Streams, где `findAny()` может вернуть более быстрый результат, чем `findFirst()`.

Важно помнить, что вызов терминальной операции консумирует Stream, и после этого он не может быть использован. Если вам
нужно будет снова обойти данные, вам потребуется создать новый Stream.

"Консумирует" в контексте Stream API означает, что после того, как на Stream была вызвана терминальная операция, Stream
становится "использованным" или "закрытым", и вы больше не можете выполнять на нем дальнейшие операции.