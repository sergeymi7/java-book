# BIG O

**Big O** нотация — это математический инструмент, используемый для описания поведения функций или алгоритмов при
стремлении их аргументов к бесконечности. В контексте анализа алгоритмов, **Big O** нотация обычно используется для
описания временной и пространственной сложности алгоритма.

**Big O** нотация представляет собой оценку верхней границы времени выполнения алгоритма или пространства, необходимого
для его выполнения. Она позволяет выразить сложность алгоритма в терминах зависимости от размера входных данных.

Например, если сложность алгоритма описывается как `O(n)`, это означает, что время выполнения алгоритма будет линейно
увеличиваться с увеличением размера входных данных. Если сложность описывается как `O(n^2)`, время выполнения будет
расти квадратично с увеличением размера входных данных.

Вот несколько примеров классов сложности, часто встречающихся в **Big O** нотации:

- `O(1)`: константное время. Время выполнения алгоритма не зависит от размера входных данных.
- `O(log n)`: логарифмическое время. Время выполнения алгоритма растет логарифмически с увеличением размера входных
  данных.
- `O(n)`: линейное время. Время выполнения алгоритма растет линейно с увеличением размера входных данных.
- `O(n log n)`: линейно-логарифмическое время. Время выполнения алгоритма растет линейно-логарифмически с увеличением
  размера входных данных.
- `O(n^2)`: квадратичное время. Время выполнения алгоритма растет квадратично с увеличением размера входных данных.
- `O(2^n)`: экспоненциальное время. Время выполнения алгоритма растет экспоненциально с увеличением размера входных
  данных.

Обратите внимание, что **Big O** нотация обычно используется для описания худшего случая, хотя она также может
использоваться для описания среднего или лучшего случая.

| Коллекция  | Добавление (add) | Получение (get) | Удаление (remove) | Поиск (contains) |
|------------|------------------|-----------------|-------------------|------------------|
| ArrayList  | O(1)*            | O(1)            | O(n)              | O(n)             |
| LinkedList | O(1)             | O(n)            | O(n)              | O(n)             |
| HashMap    | O(1)             | O(1)            | O(1)              | O(1)             |
| HashSet    | O(1)             | N/A             | O(1)              | O(1)             |

Примечание: `O(1)*` для добавления в **ArrayList** означает амортизированное время. Если массив заполнен и требуется его
расширение, операция может занять `O(n)` времени. `N/A` в столбце "Получение" для HashSet означает, что операция
неприменима, поскольку HashSet не поддерживает доступ по индексу.

### ArrayList:

- `get(int index)`: `O(1)`
- `add(E element)`: `O(1)` амортизированное время, но `O(n)` в худшем случае из-за перераспределения при достижении
  максимального размера.
- `add(int index, E element)`: `O(n)` в худшем случае, так как может потребовать сдвига элементов.
- `remove(int index)`: `O(n)` в худшем случае, так как может потребовать сдвига элементов.

### LinkedList:

- `get(int index)`: `O(n)`, так как может потребовать прохода по всему списку.
- `add(E element)`: `O(1)`, если добавление происходит в конец списка.
- `add(int index, E element)`: `O(n)` в худшем случае, так как может потребовать прохода по всему списку.
- `remove(int index)`: `O(n)` в худшем случае, так как может потребовать прохода по всему списку.

### HashMap:

- `get(Object key)`: `O(1)` в среднем, `O(n)` в худшем случае.
- `put(K key, V value)`: `O(1)` в среднем, `O(n)` в худшем случае.
- `remove(Object key)`: `O(1)` в среднем, `O(n)` в худшем случае.
- `containsKey(Object key)`: `O(1)` в среднем, `O(n)` в худшем случае.

### HashSet (основан на HashMap):

- `add(E e)`: `O(1)` в среднем, `O(n)` в худшем случае.
- `remove(Object o)`: `O(1)` в среднем, `O(n)` в худшем случае.
- `contains(Object o)`: `O(1)` в среднем, `O(n)` в худшем случае.

Обратите внимание, что "в среднем" означает, что это ожидаемое время, основанное на предположении о равномерном
распределении ключей. "В худшем случае" обычно относится к ситуациям, когда происходят коллизии хешей или когда
происходит перестройка внутренней структуры данных (например, при изменении размера).